<!doctype html>
<html lang="pt-BR">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Evolution AI Experiment</title>
<style>
  :root{
    --bg:#071020; --panel:#0c1420; --accent:#4fb3ff; --mut:#ff9f7f; --text:#dfeffb;
  }
  html,body{height:100%; margin:0; font-family:Inter, system-ui, -apple-system, "Segoe UI", Roboto; background:var(--bg); color:var(--text);}
  #ui{position:fixed; left:10px; top:10px; width:320px; background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); border-radius:12px; padding:12px; box-shadow:0 6px 18px rgba(0,0,0,0.6); z-index:20;}
  canvas{display:block; width:100vw; height:100vh;}
  button, select, input{background:transparent; color:var(--text); border:1px solid rgba(255,255,255,0.06); padding:6px 8px; margin:6px 4px 0 0; border-radius:8px; font-size:13px;}
  label{font-size:13px; display:block; margin-top:8px; color:#9fc6e6;}
  small{display:block; color:#9fb3d6; margin-top:6px;}
  .muted{color:#6e8aa6; font-size:12px;}
  .row{display:flex; gap:8px; align-items:center;}
  textarea{width:100%; height:80px; background:transparent; color:var(--text); border:1px solid rgba(255,255,255,0.04); border-radius:8px; padding:8px; resize:vertical;}
  .hint{font-size:12px; color:#8fb0d4;}
</style>
</head>
<body>
<div id="ui">
  <div class="row">
    <button id="startBtn">Start / Next Gen</button>
    <button id="autoBtn">Auto: Off</button>
    <button id="resetBtn">Reset</button>
  </div>
  <div class="row">
    <label>Pop <input id="popSize" type="number" min="4" value="24" style="width:80px"></label>
    <label>Steps <input id="simSteps" type="number" min="50" value="500" style="width:90px"></label>
  </div>
  <label>Controller
    <select id="controllerType">
      <option value="muscle">Muscle params (freq/amp/phase)</option>
      <option value="nn">Neural Net (small FF)</option>
    </select>
  </label>
  <div class="row">
    <button id="exportTemplate">Export Template</button>
    <button id="importTemplate">Import Template</button>
  </div>
  <small>Editor: clique = criar/selecionar nó, arraste = mover, right-click = conectar (duas cliques para conectar), duplo clique = alterna músculo.</small>
  <small>Fitness atual = distância X máxima (quanto mais pra direita, melhor).</small>
  <div style="margin-top:8px;">
    <div class="muted" id="status">Geração: 0 · Pop: 0 · Melhor: 0</div>
  </div>
</div>

<canvas id="c"></canvas>

<script>
/* Evolution AI Experiment
 - Editor: nodes + bones. Double-click bone endpoints to toggle muscle flag.
 - Two controller modes:
    1) muscle params per muscle (freq, amp, phase)
    2) small feedforward neural net: inputs -> hidden -> outputs (one per muscle)
 - Population uses GA: tournament selection + crossover + mutation + elitism.
 - Fitness = max x coordinate reached during sim.
*/

// Canvas setup
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
function resize(){ canvas.width = innerWidth; canvas.height = innerHeight; }
addEventListener('resize', resize);
resize();

// Editor state
let nodes = []; // {x,y,px,py,pinned}
let bones = []; // {a,b,rest,isMuscle,muscleIndex}
let dragging = null;
let connectFrom = null;
let lastClick = 0;

// Input handlers
canvas.addEventListener('pointerdown', e=>{
  const p = {x:e.clientX, y:e.clientY};
  const idx = findNodeNear(p);
  if(e.button===2){ // right-click uses contextmenu prevention; but pointerdown has no button reliable cross-browser, we'll use altKey as alternative
    e.preventDefault();
  }
  if(idx!==-1){
    dragging = idx;
  } else {
    nodes.push({x:p.x,y:p.y,px:p.x,py:p.y,pinned:false});
    updateTemplateMeta();
  }
});
canvas.addEventListener('pointermove', e=>{
  if(dragging!==null){
    nodes[dragging].x = e.clientX;
    nodes[dragging].y = e.clientY;
    updateTemplateMeta();
  }
});
canvas.addEventListener('pointerup', e=>{
  dragging = null;
});
canvas.addEventListener('dblclick', e=>{
  const idx = findNodeNear({x:e.clientX,y:e.clientY});
  if(idx!==-1){
    // toggle pin / mark for muscle connections (we will use double-click on nodes to mark as pinned)
    nodes[idx].pinned = !nodes[idx].pinned;
    updateTemplateMeta();
    return;
  }
});
canvas.addEventListener('contextmenu', e=>{
  e.preventDefault();
  const p = {x:e.clientX,y:e.clientY};
  const idx = findNodeNear(p);
  if(idx===-1) return;
  if(connectFrom===null){
    connectFrom = idx;
    flashMsg('Selecione outro nó para conectar (right-click novamente)');
  } else if(connectFrom!==idx){
    addBone(connectFrom, idx);
    connectFrom = null;
    updateTemplateMeta();
  }
});

// helpers
function findNodeNear(p){
  for(let i=0;i<nodes.length;i++){
    const n = nodes[i];
    if(Math.hypot(n.x-p.x, n.y-p.y) < 14) return i;
  }
  return -1;
}
function addBone(a,b){
  // ensure not duplicate
  for(const bb of bones){
    if((bb.a===a && bb.b===b) || (bb.a===b && bb.b===a)) return;
  }
  const rest = Math.hypot(nodes[a].x-nodes[b].x, nodes[a].y-nodes[b].y);
  bones.push({a,b,rest,isMuscle:true, muscleIndex:null});
  assignMuscleIndices();
}
function assignMuscleIndices(){
  let mid=0;
  for(const b of bones){
    if(b.isMuscle) b.muscleIndex = mid++;
    else b.muscleIndex = -1;
  }
}

// Physics (Verlet)
const gravity = 0.25;
function verletStep(ns, bs){
  // ns: array of node objects used in sim (with x,px,y,py,pinned)
  for(const n of ns){
    if(n.pinned){ n.px = n.x; n.py = n.y; continue; }
    const vx = n.x - n.px;
    const vy = n.y - n.py;
    n.px = n.x; n.py = n.y;
    n.x += vx;
    n.y += vy;
    n.y += gravity;
  }
  // constraint iterations
  for(let iter=0; iter<6; iter++){
    for(const b of bs){
      const A = ns[b.a], B = ns[b.b];
      const dx = B.x - A.x, dy = B.y - A.y;
      const cur = Math.hypot(dx,dy) || 1e-6;
      const target = b.rest;
      const diff = (cur - target)/cur;
      const corr = 0.5;
      if(!A.pinned){ A.x += dx * diff * corr; A.y += dy * diff * corr; }
      if(!B.pinned){ B.x -= dx * diff * corr; B.y -= dy * diff * corr; }
    }
    // ground
    for(const n of ns){
      if(n.y > canvas.height-6){
        n.y = canvas.height-6;
        const vx = n.x - n.px;
        n.px = n.x - vx*0.25;
      }
    }
  }
}

// Template clone utility
function cloneTemplate(){
  const tn = nodes.map(n=>({x:n.x, y:n.y, px:n.x, py:n.y, pinned:n.pinned}));
  const tb = bones.map(b=>({a:b.a, b:b.b, rest:b.rest, isMuscle:b.isMuscle, muscleIndex:b.muscleIndex}));
  return {nodes:tn, bones:tb, muscleCount: tb.filter(x=>x.isMuscle).length};
}

// Genome utilities
function randomMuscleGenome(mCount){
  const g = [];
  for(let i=0;i<mCount;i++) g.push({freq: Math.random()*2+0.1, amp: Math.random()*0.45+0.02, phase: Math.random()*Math.PI*2});
  return g;
}
// Neural net genome: flatten weights: inputs->hidden + hidden->out + biases
function createNNGenome(mCount, inputSize=4, hiddenSize=8){
  // weights input->hidden (hiddenSize * inputSize), biases hidden (hiddenSize)
  // weights hidden->out (mCount * hiddenSize), biases out (mCount)
  const arr = [];
  const total = hiddenSize*inputSize + hiddenSize + mCount*hiddenSize + mCount;
  for(let i=0;i<total;i++) arr.push((Math.random()*2-1)*0.6);
  return {arr, inputSize, hiddenSize, mCount};
}
function mutateNNGenome(g, rate=0.12){
  for(let i=0;i<g.arr.length;i++){
    if(Math.random()<rate) g.arr[i] += (Math.random()*2-1)*0.3;
  }
}
function crossoverNN(a,b){
  const out = {arr:[], inputSize:a.inputSize, hiddenSize:a.hiddenSize, mCount:a.mCount};
  for(let i=0;i<a.arr.length;i++){
    out.arr.push(Math.random()<0.5 ? a.arr[i] : b.arr[i]);
  }
  return out;
}
function mutateMuscleGenome(g, rate=0.15){
  for(const m of g){
    if(Math.random()<rate) m.freq *= Math.exp((Math.random()-0.5)*0.6);
    if(Math.random()<rate) m.amp += (Math.random()-0.5)*0.08;
    if(Math.random()<rate) m.phase += (Math.random()-0.5)*1.0;
    m.freq = clamp(m.freq,0.05,5); m.amp = clamp(m.amp,0,1);
  }
}
function crossoverMuscle(a,b){
  const out = [];
  for(let i=0;i<a.length;i++) out.push(Math.random()<0.5 ? JSON.parse(JSON.stringify(a[i])) : JSON.parse(JSON.stringify(b[i])));
  return out;
}
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

// NN forward
function nnForward(genome, inputs){
  const {arr,inputSize,hiddenSize,mCount} = genome;
  let idx = 0;
  // in->hidden
  const hidden = new Array(hiddenSize).fill(0);
  for(let h=0; h<hiddenSize; h++){
    for(let i=0;i<inputSize;i++){ hidden[h] += arr[idx++] * inputs[i]; }
  }
  // hidden biases
  for(let h=0; h<hiddenSize; h++) hidden[h] += arr[idx++];
  // activation (tanh)
  for(let h=0; h<hiddenSize; h++) hidden[h] = Math.tanh(hidden[h]);
  // hidden->out
  const outputs = new Array(mCount).fill(0);
  for(let o=0;o<mCount;o++){
    for(let h=0;h<hiddenSize;h++){ outputs[o] += arr[idx++] * hidden[h]; }
  }
  // out biases
  for(let o=0;o<mCount;o++) outputs[o] += arr[idx++];
  // final activation tanh -> [-1,1]
  for(let o=0;o<mCount;o++) outputs[o] = Math.tanh(outputs[o]);
  return outputs;
}

// Simulation of genome on template
function simulate(template, genome, steps, controllerType){
  // clone nodes/bones
  const ns = template.nodes.map(n=>({x:n.x,y:n.y,px:n.x,py:n.y,pinned:n.pinned}));
  const bs = template.bones.map(b=>({a:b.a,b:b.b,rest:b.rest,isMuscle:b.isMuscle,muscleIndex:b.muscleIndex}));
  let maxX = ns.reduce((m,n)=>Math.max(m,n.x), -1e9);
  for(let t=0;t<steps;t++){
    // controller output each step
    if(controllerType === 'muscle'){
      // genome is array of muscle params
      for(const b of bs){
        if(b.isMuscle && b.muscleIndex>=0){
          const m = genome[b.muscleIndex];
          const osc = 1 + m.amp * Math.sin((t/10) * m.freq + m.phase);
          b.rest = template.bones.find(x=>x.a===b.a && x.b===b.b).rest * osc;
        } else {
          b.rest = template.bones.find(x=>x.a===b.a && x.b===b.b).rest;
        }
      }
    } else {
      // neural net controller: compute a small set of inputs per timestep and get outputs per muscle
      // Example inputs: centroid x velocity, centroid y velocity, avg angle of bones, time sin
      const cx = ns.reduce((s,n)=>s+n.x,0)/ns.length;
      const cy = ns.reduce((s,n)=>s+n.y,0)/ns.length;
      const pvx = ns.reduce((s,n)=>s+(n.x-n.px),0)/ns.length;
      const pvy = ns.reduce((s,n)=>s+(n.y-n.py),0)/ns.length;
      const avgAngle = bs.length? bs.reduce((s,b)=>{
        const A=ns[b.a], B=ns[b.b]; return s + Math.atan2(B.y-A.y, B.x-A.x);
      },0)/bs.length : 0;
      const inputs = [pvx/3, pvy/3, Math.sin(avgAngle), Math.sin(t/40)];
      const outputs = nnForward(genome, inputs); // length = muscleCount
      for(const b of bs){
        if(b.isMuscle && b.muscleIndex>=0){
          const out = (outputs[b.muscleIndex] + 1)/2; // [0,1]
          const base = template.bones.find(x=>x.a===b.a && x.b===b.b).rest;
          b.rest = base * (1 + (out-0.5)*0.9); // vary ±45%
        } else {
          b.rest = template.bones.find(x=>x.a===b.a && x.b===b.b).rest;
        }
      }
    }

    // verlet physics step
    verletStep(ns, bs);

    // fitness probe
    for(const n of ns) if(n.x > maxX) maxX = n.x;
  }
  return maxX;
}

// Evolution engine
let population = [];
let generation = 0;
let template = null;
let auto = false;
let autoTimer = null;

function resetEvolution(){
  template = cloneTemplate();
  population = [];
  generation = 0;
  const pop = parseInt(document.getElementById('popSize').value);
  const controller = document.getElementById('controllerType').value;
  for(let i=0;i<pop;i++){
    if(controller === 'muscle'){
      population.push({genome: randomMuscleGenome(template.muscleCount), fitness:0});
    } else {
      population.push({genome: createNNGenome(template.muscleCount), fitness:0});
    }
  }
  updateStatus();
}
resetEvolution();

async function runGeneration(){
  if(!template || template.muscleCount===0){ alert('Desenhe pelo menos 1 músculo (conecte com right-click).'); return; }
  const steps = parseInt(document.getElementById('simSteps').value);
  const controller = document.getElementById('controllerType').value;

  // evaluate population
  for(let i=0;i<population.length;i++){
    const p = population[i];
    p.fitness = simulate(template, p.genome, steps, controller);
  }
  // sort desc
  population.sort((a,b)=>b.fitness - a.fitness);
  generation++;
  // GA: elitism + tournament + crossover + mutation
  const next = [];
  const elitism = Math.max(1, Math.floor(population.length*0.12));
  for(let i=0;i<elitism;i++) next.push({genome: deepCopy(population[i].genome), fitness:0});
  while(next.length < population.length){
    const parentA = tournamentSelect(population);
    const parentB = tournamentSelect(population);
    let child;
    if(controller === 'muscle'){
      const g = crossoverMuscle(parentA.genome, parentB.genome);
      mutateMuscleGenome(g, 0.18);
      child = {genome: g, fitness:0};
    } else {
      const g = crossoverNN(parentA.genome, parentB.genome);
      mutateNNGenome(g, 0.12);
      child = {genome: g, fitness:0};
    }
    next.push(child);
  }
  population = next;
  updateStatus();
  // auto preview best by running a short visual sim
  previewBest();
}

// small tournament selection
function tournamentSelect(pop){
  const a = pop[Math.floor(Math.random()*pop.length)];
  const b = pop[Math.floor(Math.random()*pop.length)];
  return (a.fitness > b.fitness) ? a : b;
}
function deepCopy(x){ return JSON.parse(JSON.stringify(x)); }

// UI handlers
document.getElementById('startBtn').addEventListener('click', async ()=>{ await runGeneration(); });
document.getElementById('resetBtn').addEventListener('click', ()=>{ resetEvolution(); });
document.getElementById('autoBtn').addEventListener('click', ()=>{
  auto = !auto;
  document.getElementById('autoBtn').innerText = 'Auto: ' + (auto ? 'On' : 'Off');
  if(auto) autoTimer = setInterval(async ()=>{ await runGeneration(); }, 1400);
  else clearInterval(autoTimer);
});
document.getElementById('controllerType').addEventListener('change', ()=>{ resetEvolution(); });

// Export / Import template
document.getElementById('exportTemplate').addEventListener('click', ()=>{
  const data = {nodes,bones};
  const txt = JSON.stringify(data, null, 2);
  downloadText('template.json', txt);
});
document.getElementById('importTemplate').addEventListener('click', ()=>{
  const s = prompt('Cole o JSON do template (nodes + bones):');
  if(!s) return;
  try{
    const data = JSON.parse(s);
    nodes = data.nodes || [];
    bones = data.bones || [];
    assignMuscleIndices();
    resetEvolution();
  }catch(err){ alert('JSON inválido.'); }
});

// download helper
function downloadText(name, txt){
  const a = document.createElement('a');
  a.href = URL.createObjectURL(new Blob([txt], {type:'application/json'}));
  a.download = name;
  a.click();
  URL.revokeObjectURL(a.href);
}

// Preview visual simulation of best genome
let preview = null;
function previewBest(){
  if(population.length===0) return;
  const best = population[0];
  if(!best) return;
  const tmpl = cloneTemplate();
  const ns = tmpl.nodes.map(n=>({x:n.x,y:n.y,px:n.x,py:n.y,pinned:n.pinned}));
  const bs = tmpl.bones.map(b=>({a:b.a,b:b.b,rest:b.rest,isMuscle:b.isMuscle,muscleIndex:b.muscleIndex}));
  preview = {ns, bs, genome: deepCopy(best.genome), t:0, maxT: Math.min(700, parseInt(document.getElementById('simSteps').value))};
}

// Render loop
function render(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  // background
  ctx.fillStyle = '#04101a'; ctx.fillRect(0,0,canvas.width,canvas.height);
  // editor bones
  for(const b of bones){
    const A = nodes[b.a], B = nodes[b.b];
    ctx.lineWidth = b.isMuscle ? 4 : 3;
    ctx.strokeStyle = b.isMuscle ? 'rgba(255,140,90,0.95)' : 'rgba(80,160,255,0.9)';
    ctx.beginPath(); ctx.moveTo(A.x,A.y); ctx.lineTo(B.x,B.y); ctx.stroke();
  }
  // nodes
  for(let i=0;i<nodes.length;i++){
    const n = nodes[i];
    ctx.beginPath();
    ctx.fillStyle = n.pinned ? '#ffd86b' : '#bfe6ff';
    ctx.arc(n.x,n.y,7,0,Math.PI*2); ctx.fill();
    ctx.fillStyle = '#08202e';
    ctx.font = '11px Inter';
    ctx.fillText(i,n.x-3,n.y+3);
  }

  // preview sim (if any)
  if(preview){
    // step small amounts for smooth visuals
    for(let s=0; s<2 && preview.t < preview.maxT; s++){
      // apply controller like in simulate()
      const controller = document.getElementById('controllerType').value;
      if(controller === 'muscle'){
        for(const b of preview.bs){
          if(b.isMuscle && b.muscleIndex>=0){
            const m = preview.genome[b.muscleIndex];
            const osc = 1 + m.amp * Math.sin((preview.t/10) * m.freq + m.phase);
            b.rest = preview.bs.find(x=>x.a===b.a && x.b===b.b).rest;
            // base rest from template nodes (we didn't keep template.rest separately, but initial rest is in b.rest)
            b.rest = preview.bs.find(x=>x.a===b.a && x.b===b.b).rest * osc;
          }
        }
      } else {
        const ns = preview.ns;
        const bs = preview.bs;
        const cx = ns.reduce((s,n)=>s+n.x,0)/ns.length;
        const pvx = ns.reduce((s,n)=>s+(n.x-n.px),0)/ns.length;
        const pvy = ns.reduce((s,n)=>s+(n.y-n.py),0)/ns.length;
        const avgAngle = bs.length? bs.reduce((s,b)=> { const A=ns[b.a], B=ns[b.b]; return s + Math.atan2(B.y-A.y,B.x-A.x); },0)/bs.length : 0;
        const inputs = [pvx/3, pvy/3, Math.sin(avgAngle), Math.sin(preview.t/40)];
        const outputs = nnForward(preview.genome, inputs);
        for(const b of bs){
          if(b.isMuscle && b.muscleIndex>=0){
            const out = (outputs[b.muscleIndex]+1)/2;
            const base = b.rest; // initial rest as baseline
            b.rest = base * (1 + (out-0.5)*0.9);
          }
        }
      }
      verletStep(preview.ns, preview.bs);
      preview.t++;
    }

    // draw preview skeleton overlay
    for(const b of preview.bs){
      const A = preview.ns[b.a], B = preview.ns[b.b];
      ctx.lineWidth = 3.5;
      ctx.strokeStyle = 'rgba(240,240,255,0.9)';
      ctx.beginPath(); ctx.moveTo(A.x,A.y); ctx.lineTo(B.x,B.y); ctx.stroke();
    }
    for(const n of preview.ns){
      ctx.beginPath(); ctx.fillStyle = 'rgba(255,255,255,0.95)'; ctx.arc(n.x,n.y,4.5,0,Math.PI*2); ctx.fill();
    }
    if(preview.t >= preview.maxT) preview = null;
  }

  // HUD
  ctx.fillStyle = '#cfe9ff';
  ctx.font = '13px Inter';
  const bestFitness = (population.length && population[0].fitness) ? Math.round(population[0].fitness) : 0;
  ctx.fillText(`Gen: ${generation}  Pop: ${population.length}  BestX: ${bestFitness}`, 14, canvas.height - 18);

  requestAnimationFrame(render);
}
requestAnimationFrame(render);

// Update status text
function updateStatus(){
  const best = population.length && population[0].fitness ? Math.round(population[0].fitness) : 0;
  document.getElementById('status').innerText = `Geração: ${generation} · Pop: ${population.length} · Melhor: ${best}`;
}

// Utility: flash message in status area briefly
function flashMsg(t){
  const el = document.getElementById('status');
  const prev = el.innerText;
  el.innerText = t;
  setTimeout(()=> el.innerText = prev, 1800);
}

// Keep template meta in sync (reassign muscle indices)
function updateTemplateMeta(){ assignMuscleIndices(); resetEvolution(); }

// Prevent accidental text selection
document.body.addEventListener('mousedown', e=>{ e.preventDefault(); });

// Initial helper demo template (one simple walker) to save time
function makeDemoTemplate(){
  nodes = [
    {x:200,y:300,px:200,py:300,pinned:false},
    {x:260,y:300,px:260,py:300,pinned:false},
    {x:320,y:300,px:320,py:300,pinned:false},
    {x:260,y:250,px:260,py:250,pinned:false}
  ];
  bones = [];
  function add(a,b){ const rest = Math.hypot(nodes[a].x-nodes[b].x, nodes[a].y-nodes[b].y); bones.push({a,b,rest,isMuscle:true,muscleIndex:null}); }
  add(0,1); add(1,2); add(1,3);
  assignMuscleIndices();
  resetEvolution();
}
makeDemoTemplate();

</script>
</body>
</html>
